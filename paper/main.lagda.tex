\documentclass[preprint]{sigplanconf}

%include agda.fmt
\def\textmu{}
\include{preamble}

\begin{document}

\conferenceinfo{ICFP'14} {September 1--3, 2014, G\"oteborg, Sweden}

\title{Auto for Agda: Programming Proof Search}

\authorinfo{Pepijn Kokke \and Wouter Swierstra}
           {Universiteit Utrecht}
           {\todo{Add email addresses here.}}
\maketitle

\begin{abstract}
\todo{Add the abstract here.}
Proof automation is important. Custom tactic languages are hacky. We
show how proof automation can be programmed in a general purpose
dependently typed programming language using reflection. This makes
it easier to automate, debug, and test proof automation.\todo{Write good abstract}
\end{abstract}

\section{Introduction}
\label{sec:intro}

Writing proof terms in type theory is hard and often tedious.
Interactive proof assistants based on type theory, such as
Agda~\cite{agda} or Coq~\cite{coq}, take
very different approaches to facilitating this process.

The Coq proof assistant has two distinct language fragments. Besides the
programming language Gallina, there is a separate tactic language for
writing and programming proof scripts. Together with several highly
customizable tactics, the tactic language Ltac can provide powerful
proof automation~\cite{chlipala}. Having to introduce a
separate tactic language, however, seems at odds with the spirit of type
theory, where a single language is used for both proof and computation.
Having a separate language for programming proofs has its
drawbacks. Programmers need to learn another language to automate
proofs. Debugging Ltac programs can be difficult and the resulting
proof automation may be inefficient~\cite{brabaint}.


Agda does not have Coq's segregation of proof and programming language.
Instead, programmers are encouraged to automate proofs by writing their
own solvers~\cite{ulf-tphols}. In combination with
Agda's reflection mechanism~\cite{van-der-walt},
developers can write powerful automatic decision
procedures~\cite{allais}. Unfortunately, not all proofs
are easily automated in this fashion. When this is the case, the user is
forced to interact with the integrated development environment and
construct a proof term step by step.

This paper tries to combine the best of both worlds by implementing
tactics for proof search \emph{within} Agda itself. More specifically,
this paper makes the following novel contributions:

\begin{itemize}
\item
  We show how to implement a Prolog interpreter in the style of
  \citet{stutterheim} in Agda (Section~\ref{sec:prolog}). Note that,
  in contrast to Agda, Prolog programs need not terminate. Using coinduction,
  however, we can write a \emph{total} interpreter for Prolog.
\item
  We extend this interpreter to not only produce the substitution that
  solves a Prolog goal, but also produce a proof tree
  (Section~\ref{sec:proofs}). This proof tree will serve
  as a witness for a proof found in this fashion.
\item
  We integrate this proof search algorithm with Agda's \emph{reflection}
  mechanism (Section~\ref{sec:reflection}. This enables
  us to quote the type of a goal, pass this to our Prolog-style
  interpreter, and unquote the resulting proof tree as a proof of our
  goal.
\item
  \wouter{Example? Can we use our proof search to find out why a proof
  is not being found automatically?} \pepijn{I don't see how you would
  envision this---all we can say is ``No, all combinations of up to $d$
  of your hints fail to produce anything meaningful''---which, I suppose
  is not what you're after.}
\item
  \pepijn{Should we mention here that our algorithm passes the
  termination checker in its entirety?}
\end{itemize}



\section{Motivation}
\label{sec:motivation}

Before describing the \emph{implementation} of our library, we will
give a brief motivating example illustrating its \emph{use}.

We can define a predicate |Even| on natural numbers as follows:

\begin{code}
  data Even : ℕ → Set where
    Base : Even 0
    Step : ∀ {n} → Even n → Even (suc (suc n))
\end{code}

Next we can prove properties of this definition:

\begin{code}
  evenSum : ∀ {n m} → Even n → Even m → Even (n + m)
  evenSum  Base     e2 = e2
  evenSum (Step e1) e2 = Step (evenSum e1 e2)
\end{code}

As shown by~\citet{van-der-walt} proving the |Even| property for closed
terms can easily be done. The interesting terms, however, are never closed.
For instance, if we, in the below proof, would like to use the |evenSum|
lemma, we need to explicitly call it.

\begin{code}
  simple : ∀ {n} → Even n → Even (n + 2)
  simple e =  evenSum e (Step Base)
\end{code}

This has its drawbacks. Constructing explicit proof objects in this
fashion is not easy. The proof is brittle. We cannot easily reuse it
to prove similar statements such as |Even (n + 4)|. If we need to
reformulate our statement slightly, proving |Even (2 + n)| instead, we
need to rewrite our proof. Proof automation could really help here.

In Coq, tactics such as |auto| can be customized to handle all these
examples. Using high-level tactics makes the proof more robust against
reformulations of the exact proof statement. This paper shows how to
implement such an |auto| tactic in Agda.

Instead we would like to assemble any lemmas useful in our domain in a
hint database:

\begin{code}
  hints : HintDB
  hints = hintdb (quote Base
                  :: quote Step
                  :: quote evenSum
                  :: [])
\end{code}

Next we use Agda's reflection mechanism to obtain a representation of
the goal that we are trying to prove. The language construct \textbf{quoteGoal}
g \textbf{in} ... binds the type of the current goal to |g|; we then call a
\emph{function} |auto|, passing our hint database and goal as arguments.
The |auto| function tries to construct a proof term of type |Even n → Even
(n + 2)| from the hint database. If this is successful, we unquote the
proof term:

This goes beyond what is currently possible using the Agsy proof search.
In particular, we can add hints to a database; customize the search depth;
or even implement our own search strategy.

\begin{code}
  test : ∀ {n} → Even n → Even (n + 2)
  test = quoteGoal g in unquote (auto 5 hints g)
\end{code}

Of course, such invocations of the |auto| function may fail. So what happens
if no proof exists? In that case, the |auto| function generates a dummy term,
whose type explains that the search space has been exhausted. Unquoting this
term, then gives a type error message. For example, trying to prove |Even n →
Even (n + 3)| in this style gives the following error:

\begin{verbatim}
  Err searchSpaceExhausted !=<
    Even .n -> Even (.n + 3) of type Set
\end{verbatim}



\section{Prolog in Agda}
\label{sec:prolog}

\subsection{Terms and Rules}

The heart of our proof search implementation is the structurally recursive
unification algorithm described by~\citet{mcbride}. In this approach, terms
are encoded using finite sets for variables. This allows the algorithm to
be structurally recusive on the number of variables in a term. In addition
to this we encode constants as a |Name| with a fixed arity and a vector of
arguments.\footnote{
  In our Prolog implementation the type |Name| is left abstract, to be
  supplied by the user. The implementation of |auto| identifies it with
  an arity-annotated version of the language construct |QName|.
}

\begin{code}
  data Term (n : ℕ) : Set where
    var  : Fin n → Term n
    con  : ∀ {k} → Name k → Vec (Term n) k → Term n
\end{code}

We shall refrain from further discussion of the unification algorithm---the
interested reader can refer to~\cite{mcbride} for a detailed description.
Suffices to say that an implementation leaves us with a unifiction function
of the following type:

\begin{spec}
  unify : ∀ {m} (t₁ t₂ : Term m) → Maybe (∃ n → Subst m n)
\end{spec}

That is, given two terms $t_1$ and $t_2$, it will compute the most general
unifier in the form of a substition that takes terms with at most $m$ free
variables to terms with at most $n$.


Next we define Prolog rules as records containing a rulename and terms for its
premises and conclusion---and again the datatype is quantified over the number of
variables used by its constituents. Note that variables are shared between the
premises and conclusion. \pepijn{Is having two types called |Name| confusing?
In the Auto module I make the distinction between |AgdaName| and |PrologName|;
should I make a distinction here between, say, |Constr| and |RuleName|?}

\begin{code}
  record Rule (n : ℕ) : Set where
    field
      name        : Name
      conclusion  : Term n
      premises    : List (Term n)
\end{code}


Lastly, before we can implement some form of proof search, we are going to need
to define injection and raiseing function for terms, rules and substitions.
We will give a definition for these function on finite sets below, and leave the
implementations for the more complex constituents up to the reader.

\begin{code}
  inject : ∀ {m} n → Fin m → Fin (m + n)
  inject n  zero    = zero
  inject n (suc i)  = suc (inject n i)

  raise : ∀ m {n} → Fin n → Fin (m + n)
  raise  zero   i  = i
  raise (suc m) i  = suc (raise m i)
\end{code}

\pepijn{This explanation is pretty terrible---any advice?}
Why do we need these functions? First, let's examine what they do for finite sets:
|inject| will send a number $i$ from a finite set of size $n$, to the \emph{same}
number in a set which is $m$ larger.
On the contrary, |raise| will send a number $i$ from a finite set of size $n$ to a
number $i + m$ in a set which is $m$ larger.

If we consider the effects of these function on |Term|s, we find that |inject|
increases the number of variables that can occur, but keeps the variable names
the same; |raise|, however, not only increases the number of variables, but also
replaces all variables with variables that are \emph{guaranteed} to be fresh.



\subsection{Proof search}

\pepijn{I... don't know. Should I try to unify the two below structures \emph{before}
I describe them in the paper? We cannot give a concrete reason for why they are
separated, except maybe to keep the concept of rule application and substitutions
out out of concept of search trees.}

\begin{code}
  data SearchSpace (m : ℕ) : Set where
    done : (∃₂ δ n → Subst (m + δ) n) → SearchSpace m
    step : (∃ Rule → ∞ (SearchSpace m)) → SearchSpace m
\end{code}

\begin{code}
  data SearchTree (A : Set) : Set where
    fail : SearchTree A
    retn : A → SearchTree A
    fork : ∞ (List (SearchTree A)) → SearchTree A
\end{code}

 
\section{Constructing proof trees}
\label{sec:proofs}

\section{Adding reflection}
\label{sec:reflection}

\section{Discussion}
\label{sec:discussion}

\todo{Mention Idris}

Future work: auto rewrite; setoid rewrite; proof combinators.

\bibliographystyle{plainnat}
\bibliography{main}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% TeX-command-default: "rake"
%%% End:
