\documentclass[preprint]{sigplanconf}

%include agda.fmt
\include{preamble}

\begin{document}

\conferenceinfo{ICFP'14} {September 1--3, 2014, G\"oteborg, Sweden}

\title{Auto for Agda: Programming Proof Search}

\authorinfo{Pepijn Kokke \and Wouter Swierstra}
           {Universiteit Utrecht}
           {\todo{Add email addresses here.}}
\maketitle



\begin{abstract}
\todo{Add the abstract here.}
Bacon ipsum dolor sit amet fugiat exercitation andouille pork belly ut ex
reprehenderit leberkas est kevin. Aute bresaola beef id elit, jerky jowl pork
belly. Adipisicing dolore meatball, leberkas excepteur biltong hamburger minim
do id kevin pork venison incididunt pariatur. Short ribs aute turkey prosciutto
landjaeger andouille adipisicing ham, mollit beef veniam shoulder. Pariatur ut
adipisicing laboris.
\end{abstract}



\section{Introduction}
\label{sec:intro}

Writing proof terms in type theory is hard and often tedious.
Interactive proof assistants based on type theory, such as
Agda~\cite{agda} or Coq~\cite{coq}, take
very different approaches to facilitating this process.

The Coq proof assistant has two distinct language fragments. Besides the
programming language Gallina, there is a separate tactic language for
writing and programming proof scripts. Together with several highly
customizable tactics, the tactic language Ltac can provide powerful
proof automation~\cite{chlipala}. Having to introduce a
separate tactic language, however, seems at odds with the spirit of type
theory, where a single language is used for both proof and computation.

Agda does not have Coq's segregation of proof and programming language.
Instead, programmers are encouraged to automate proofs by writing their
own solvers~\cite{ulf-tphols}. In combination with
Agda's reflection mechanism~\cite{van-der-walt},
developers can write powerful automatic decision
procedures~\cite{allais}. Unfortunately, not all proofs
are easily automated in this fashion. When this is the case, the user is
forced to interact with the integrated development environment and
construct a proof term step by step.

This paper tries to combine the best of both worlds by implementing
tactics for proof search \emph{within} Agda itself. More specifically,
this paper makes the following novel contributions:

\begin{itemize}
\item
  We show how to implement a Prolog interpreter in the style of
  \citet{stutterheim} in Agda (Section~\ref{sec:prolog}). Note that,
  in contrast to Agda, Prolog programs need not terminate. Using coinduction,
  however, we can write a \emph{total} interpreter for Prolog.
\item
  We extend this interpreter to not only produce the substitution that
  solves a Prolog goal, but also produce a proof tree
  (Section~\ref{sec:proofs}). This proof tree will serve
  as a witness for a proof found in this fashion.
\item
  We integrate this proof search algorithm with Agda's \emph{reflection}
  mechanism (Section~\ref{sec:reflection}. This enables
  us to quote the type of a goal, pass this to our Prolog-style
  interpreter, and unquote the resulting proof tree as a proof of our
  goal.
\item
  \wouter{Example? Can we use our proof search to find out why a proof
  is not being found automatically?} \pepijn{I don't see how you would
  envision this---all we can say is ``No, all combinations of up to $d$
  of your hints fail to produce anything meaningful''---which, I suppose
  is not what you're after.}
\item
  \pepijn{Should we mention here that our algorithm passes the
  termination checker in its entirety?}
\end{itemize}



\section{Motivation}
\label{sec:motivation}

Before describing the \emph{implementation} of our library, we will
give a brief motivating example describing its \emph{use}.

We can define a predicate |Even| on natural numbers as follows:

\begin{code}
  data Even : ℕ → Set where
    Base : Even 0
    Step : ∀ {n} → Even n → Even (suc (suc n))
\end{code}

Next we can prove properties of this definition:

\begin{code}
  evenSum : ∀ {n m} → Even n → Even m → Even (n + m)
  evenSum  Base     e2 = e2
  evenSum (Step e1) e2 = Step (evenSum e1 e2)
\end{code}

As shown by~\citet{van-der-walt} proving the |Even| property for closed
terms can easily be done. The interesting terms, however, are never closed.
For instance, if we, in the below proof, would like to use the |evenSum|
lemma, we need to explicitly call it.

\begin{code}
  simple : ∀ {n} → Even n → Even (n + 2)
  simple e =  evenSum e (Step Base)
\end{code}

This has its drawbacks. Constructing explicit proof objects in this
fashion is not easy. The proof is brittle. We cannot easily reuse it
to prove similar statements such as |Even (n + 4)|. If we need to
reformulate our statement slightly, proving |Even (2 + n)| instead, we
need to rewrite our proof. Proof automation could really help here.

In Coq, tactics such as |auto| can be customized to handle all these
examples. Using high-level tactics makes the proof more robust against
reformulations of the exact proof statement. This paper shows how to
implement such an |auto| tactic in Agda.

Instead we would like to assemble any lemmas useful in our domain in a
hint database:

\begin{code}
  hints : HintDB
  hints = hintdb (quote Base
                  :: quote Step
                  :: quote evenSum
                  :: [])
\end{code}

Next we use Agda's reflection mechanism to obtain a representation of
the goal that we are trying to prove. The language construct \textbf{quoteGoal}
g \textbf{in} ... binds the type of the current goal to |g|; we then call a
\emph{function} |auto|, passing our hint database and goal as arguments.
The |auto| function tries to construct a proof term of type |Even n → Even
(n + 2)| from the hint database. If this is successful, we unquote the
proof term:

This goes beyond what is currently possible using the Agsy proof search.
In particular, we can add hints to a database; customize the search depth;
or even implement our own search strategy.

\begin{code}
  test : ∀ {n} → Even n → Even (n + 2)
  test = quoteGoal g in unquote (auto 5 hints g)
\end{code}

Of course, such invocations of the |auto| function may fail. So what happens
if no proof exists? In that case, the |auto| function generates a dummy term,
whose type explains that the search space has been exhausted. Unquoting this
term, then gives a type error message. For example, trying to prove |Even n →
Even (n + 3)| in this style gives the following error:

\begin{verbatim}
  Err searchSpaceExhausted !=<
    Even .n -> Even (.n + 3) of type Set
\end{verbatim}



\section{Prolog in Agda}
\label{sec:prolog}

The heart of our proof search implementation is the structurally recursive
unification algorithm described by~\citet{mcbride}. In this approach, terms
are encoded using finite sets for variables. This allows the algorithm to
be structurally recusive on the number of variables in a term.

\begin{code}
  data Term (n : ℕ) : Set where
    var  : Fin n → Term n
    con  : ∀ {k} → Name k → Vec (Term n) k → Term n
\end{code}

\end{document}